globalPriceMultiplier = 0.6
PI = math.pi
TWO_PI = 2 * PI
PI_2 = PI / 2
lobbyCoords = {
  {
    -1392.2332,
    2483.7261,
    64.3333,
    75,
    "Silver Vein",
    7,
    -1383.3199,
    2481.1626,
    67.1384,
    -15,
    "v4_mine_entrance1"
  },
  {
    -1382.5136,
    2308.9375,
    55.5651,
    110,
    "Golden Summit",
    7,
    -1372.9541,
    2312.1562,
    57.8662,
    19.5,
    "v4_mine_entrance2"
  },
  {
    -1209.3429,
    2052.2058,
    78.3374,
    390,
    "Diamond Depths",
    7,
    -1204.8247,
    2044.1183,
    80.4349,
    300,
    "v4_mine_entrance3"
  },
  {
    -1199.7081,
    2248.9207,
    101.5691,
    209,
    "Emerald Grotto",
    7,
    -1204.2206,
    2257.3367,
    104.1957,
    119,
    "v4_mine_entrance4"
  },
  {
    -1274.3549,
    2231.1531,
    100.0635,
    160,
    "Granite Ridge",
    7,
    -1271.4425,
    2240.0256,
    102.0696,
    70,
    "v4_mine_entrance5"
  },
  {
    -1323.0405,
    2286.3484,
    94.9378,
    105,
    "Sapphire Shaft",
    7,
    -1313.8759,
    2288.4141,
    97.2358,
    15,
    "v4_mine_entrance6"
  }
}
lobbyPosX = 0
lobbyPosY = 0
lobbyPosZ = 7000
lobbyExitX = lobbyPosX - 68.5956
lobbyExitY = lobbyPosY - 4.1388
lobbyExitZ = lobbyPosZ + 15.4
lobbyExitAngle = 280
minePosX = 0
minePosY = 0
minePosZ = 9000
mineHqX = minePosX - 12
mineHqY = minePosY
mineHqZ = minePosZ
mineCoords = {
  {
    -62.031,
    22.1692,
    14.4102,
    -19,
    0,
    0,
    -66.1584,
    22.957,
    16.4061,
    -20
  },
  {
    -21.269,
    50.9555,
    14.4102,
    -88,
    0,
    0,
    -20.6588,
    55.119,
    16.3934,
    -88.7
  },
  {
    13.4124,
    47.2191,
    14.4102,
    -95,
    0,
    0,
    13.8231,
    51.3455,
    16.3899,
    -95
  },
  {
    42.425,
    37.3044,
    14.4102,
    -120,
    0,
    0,
    43.9592,
    41.2286,
    16.4061,
    -122
  },
  {
    65.2181,
    10.219,
    14.4102,
    -168,
    0,
    0,
    69.4343,
    10.3672,
    16.3934,
    -167
  },
  {
    63.3537,
    -21.5917,
    14.4102,
    -200,
    0,
    0,
    67.0441,
    -23.5695,
    15.9222,
    -200
  },
  {
    37.7136,
    -47.1174,
    14.4102,
    -257,
    0,
    0,
    37.9069,
    -51.3267,
    16.3934,
    -258
  },
  {
    1.2827,
    -51.8774,
    14.4102,
    -269,
    0,
    0,
    1.2659,
    -56.0249,
    16.3982,
    -270
  },
  {
    -29.9952,
    -45.9858,
    14.4102,
    -294,
    0,
    0,
    -32.3298,
    -49.4811,
    16.3934,
    -294.5
  },
  {
    -54.0439,
    -27.742,
    14.4102,
    -324,
    0,
    0,
    -57.0167,
    -30.6927,
    16.3934,
    -323
  },
  {
    48.5383,
    -11.2455,
    6.4102,
    -193,
    0,
    0,
    52.4045,
    -12.9354,
    8.3934,
    -193
  },
  {
    26.5044,
    -35.1056,
    6.4102,
    -258,
    0,
    0,
    27.9762,
    -39.0322,
    8.3934,
    -258
  },
  {
    -9.8843,
    -36.2369,
    6.4102,
    -275,
    0,
    0,
    -10.3376,
    -40.3593,
    8.3982,
    -276
  },
  {
    -44.4243,
    -18.7358,
    6.4102,
    -324,
    0,
    0,
    -48.2133,
    -20.5879,
    8.3982,
    -323.5
  },
  {
    -49.6838,
    15.4658,
    6.4102,
    -30,
    0,
    0,
    -52.8896,
    18.1905,
    8.3934,
    -30
  },
  {
    -22.0536,
    33.4099,
    6.4102,
    -93,
    0,
    0,
    -22.4636,
    37.5806,
    8.4061,
    -93
  },
  {
    12.9467,
    32.0101,
    6.4102,
    -92,
    0,
    0,
    13.8879,
    36.1208,
    8.3934,
    -92.5
  },
  {
    32.4336,
    -1.7902,
    0.0102,
    -166,
    0,
    0,
    36.6303,
    -1.529,
    1.9934,
    -167
  },
  {
    3.7477,
    13.9176,
    0.0102,
    -89.5,
    0,
    0,
    4.4661,
    18.064,
    1.9934,
    -90
  },
  {
    -31.523,
    10.7258,
    0.0102,
    -15,
    0,
    0,
    -35.6904,
    11.2024,
    1.9934,
    -15
  }
}
for _FORV_4_ = 1, #mineCoords do
  mineCoords[_FORV_4_][1] = lobbyPosX + mineCoords[_FORV_4_][1]
  mineCoords[_FORV_4_][2] = lobbyPosY + mineCoords[_FORV_4_][2]
  mineCoords[_FORV_4_][3] = lobbyPosZ + mineCoords[_FORV_4_][3]
  mineCoords[_FORV_4_][7] = lobbyPosX + mineCoords[_FORV_4_][7]
  mineCoords[_FORV_4_][8] = lobbyPosY + mineCoords[_FORV_4_][8]
  mineCoords[_FORV_4_][6], mineCoords[_FORV_4_][9] = mineCoords[_FORV_4_][4], lobbyPosZ + mineCoords[_FORV_4_][9]
  mineCoords[_FORV_4_][4] = math.cos((math.rad(mineCoords[_FORV_4_][4])))
  mineCoords[_FORV_4_][5] = math.sin((math.rad(mineCoords[_FORV_4_][4])))
  mineCoords[_FORV_4_][11] = math.cos((math.rad(mineCoords[_FORV_4_][10])))
  mineCoords[_FORV_4_][12] = math.sin((math.rad(mineCoords[_FORV_4_][10])))
end
function getLobbyFromCorridor(_ARG_0_)
  return math.floor((_ARG_0_ - 1) / _UPVALUE0_) + 1, _ARG_0_ - (math.floor((_ARG_0_ - 1) / _UPVALUE0_) + 1 - 1) * _UPVALUE0_
end
function getLobbyCorridorBaseId(_ARG_0_)
  return (_ARG_0_ - 1) * _UPVALUE0_
end
function getCorridorIdFromLobbyCorridor(_ARG_0_, _ARG_1_)
  return (_ARG_0_ - 1) * _UPVALUE0_ + _ARG_1_
end
function getLobbyMineBaseId(_ARG_0_, _ARG_1_)
  return (_ARG_0_ - 1) * _UPVALUE0_ + (_ARG_1_ - 1) * _UPVALUE1_
end
function getLobbyMineId(_ARG_0_, _ARG_1_)
  return getLobbyMineBaseId(getLobbyFromCorridor(_ARG_0_)) + _ARG_1_
end
function getLobbyFromMineId(_ARG_0_)
  return math.floor(_ARG_0_ / _UPVALUE0_) + 1, math.floor((_ARG_0_ - (math.floor(_ARG_0_ / _UPVALUE0_) + 1 - 1) * _UPVALUE0_) / _UPVALUE1_) + 1, _ARG_0_ - getLobbyMineBaseId(math.floor(_ARG_0_ / _UPVALUE0_) + 1, math.floor((_ARG_0_ - (math.floor(_ARG_0_ / _UPVALUE0_) + 1 - 1) * _UPVALUE0_) / _UPVALUE1_) + 1)
end
function isValidLobbyCorridor(_ARG_0_)
  if getLobbyFromCorridor(_ARG_0_) < 1 or getLobbyFromCorridor(_ARG_0_) > #lobbyCoords then
    return false
  end
  if getLobbyFromCorridor(_ARG_0_) < 1 or getLobbyFromCorridor(_ARG_0_) > lobbyCoords[getLobbyFromCorridor(_ARG_0_)][6] then
    return false
  end
  return true
end
function validateMineId(_ARG_0_, _ARG_1_)
  return _ARG_1_ and _ARG_0_ < _ARG_1_ and _ARG_1_ <= _ARG_0_ + _UPVALUE0_
end
function formatMineName(_ARG_0_)
  return lobbyCoords[getLobbyFromMineId(_ARG_0_)][5] .. " bánya " .. getLobbyFromMineId(_ARG_0_) .. ". járat " .. getLobbyFromMineId(_ARG_0_) .. ". ajtó"
end
function formatNumber(_ARG_0_)
  while true do
    if string.gsub(tostring(_ARG_0_), "^(-?%d+)(%d%d%d)", "%1 %2") == 0 then
      break
    end
  end
  return string.gsub(tostring(_ARG_0_), "^(-?%d+)(%d%d%d)", "%1 %2")
end
function convertMineCoordinates(_ARG_0_, _ARG_1_)
  return math.floor(_ARG_0_ / 6 - 0.5) + 1, math.floor(_ARG_1_ / 6 - 0.5) + 1
end
function convertSingleMineCoordinate(_ARG_0_)
  return math.floor(_ARG_0_ / 6 - 0.5) + 1
end
rentPrice = math.floor(50000 * globalPriceMultiplier + 0.5)
rentDeposit = 4 * rentPrice
ppRentPrice = 1750
ppRentDeposit = 0 * ppRentPrice
rentDuration = 604800
renewalDuration = 172800
maxWorkers = 10
maxWorkersInside = 5
permissionFlags = {
  OPEN_CLOSE = bitLShift(1, 0),
  MINING = bitLShift(1, 1),
  USE_BOMB = bitLShift(1, 2),
  PICK_ORES = bitLShift(1, 3),
  CONSTRUCT_LAMP = bitLShift(1, 4),
  USE_RAILCAR = bitLShift(1, 5),
  USE_SWITCHES = bitLShift(1, 6),
  CONSTRUCT_RAIL = bitLShift(1, 7),
  USE_SORTER_MACHINE = bitLShift(1, 8),
  USE_FOUNDRY = bitLShift(1, 9),
  ORDER = bitLShift(1, 10),
  COLLECT_PRODUCT = bitLShift(1, 11)
}
permissionDescriptions = {
  [permissionFlags.OPEN_CLOSE] = "Nyitás/Zárás",
  [permissionFlags.MINING] = "Bányászat",
  [permissionFlags.USE_BOMB] = "Robbantás",
  [permissionFlags.PICK_ORES] = "Ércek pakolása",
  [permissionFlags.CONSTRUCT_LAMP] = "Lámpa felszerelése",
  [permissionFlags.USE_RAILCAR] = "Vonat használata",
  [permissionFlags.USE_SWITCHES] = "Váltókezelés",
  [permissionFlags.CONSTRUCT_RAIL] = "Sínépítés",
  [permissionFlags.USE_SORTER_MACHINE] = "Válogatógép kezelése",
  [permissionFlags.USE_FOUNDRY] = "Kohó kezelés",
  [permissionFlags.ORDER] = "Rendelés",
  [permissionFlags.COLLECT_PRODUCT] = "Késztermék begyűjtése"
}
permissionList = {}
for _FORV_7_ in pairs(permissionFlags) do
  table.insert(permissionList, _FORV_7_)
end
table.sort(permissionList, function(_ARG_0_, _ARG_1_)
  return permissionFlags[_ARG_0_] < permissionFlags[_ARG_1_]
end)
function canExtendShaftAt(_ARG_0_, _ARG_1_)
  return _ARG_0_ > 0 and _ARG_0_ % 2 == 1 and _ARG_1_ % 2 == 0
end
function prad(_ARG_0_)
  if not _UPVALUE0_[_ARG_0_] then
    _UPVALUE0_[_ARG_0_] = math.rad(math.floor(_ARG_0_ / 90 + 0.5) * 90)
  end
  return _UPVALUE0_[_ARG_0_]
end
function pcos(_ARG_0_)
  if not _UPVALUE0_[_ARG_0_] then
    _UPVALUE0_[_ARG_0_] = math.floor(math.cos(_ARG_0_) + 0.5)
  end
  return _UPVALUE0_[_ARG_0_]
end
function psin(_ARG_0_)
  if not _UPVALUE0_[_ARG_0_] then
    _UPVALUE0_[_ARG_0_] = math.floor(math.sin(_ARG_0_) + 0.5)
  end
  return _UPVALUE0_[_ARG_0_]
end
function patan2(_ARG_0_, _ARG_1_)
  if not _UPVALUE0_[_ARG_0_] then
    _UPVALUE0_[_ARG_0_] = {}
  end
  if not _UPVALUE0_[_ARG_0_][_ARG_1_] then
    _UPVALUE0_[_ARG_0_][_ARG_1_] = math.atan2(_ARG_0_, _ARG_1_)
  end
  return _UPVALUE0_[_ARG_0_][_ARG_1_]
end
wallVertexNumX = 20
wallVertexNumY = 19
wallVertexCount = wallVertexNumX * wallVertexNumY * 6
wallBlockNumX = 3
wallBlockNumY = 3
wallBlockCount = wallBlockNumX * wallBlockNumY
wallMeshWidth = 3.5
wallMeshHeight = 2.83206
wallTextureWidth = 256
wallTextureHeight = 256
wallMinimumDepth = 0.085
wallMaximumDepth = 0.85
function remapRgb(_ARG_0_, _ARG_1_, _ARG_2_, _ARG_3_)
  return _ARG_0_ / 255, _ARG_1_ / 255, _ARG_2_ / 255, _ARG_3_ and _ARG_3_ / 255 or 1
end
oreTypes = {
  sapphire = {
    itemId = 701,
    itemProbability = 15,
    forexIndex = "SAP",
    displayName = "Zafír",
    actionName = "zafírt",
    sorterOffset = 0.322243,
    metallicOre = true
  },
  amber = {
    itemId = 702,
    itemProbability = 30,
    forexIndex = "AMB",
    displayName = "Borostyán",
    actionName = "borostyánt",
    sorterOffset = 0.966825,
    metallicOre = true
  },
  amethyst = {
    itemId = 703,
    itemProbability = 110,
    forexIndex = "AME",
    displayName = "Ametiszt",
    actionName = "ametisztet",
    sorterOffset = 1.611407,
    metallicOre = true
  },
  bauxite = {
    itemId = 704,
    itemProbability = 425,
    forexIndex = "ALU",
    displayName = "Bauxit",
    actionName = "alumínium rudat",
    ingotName = "Alumínium",
    ingotNamePrefix = "az",
    meltingPoint = 670,
    meltingColor = {
      remapRgb(198, 198, 198)
    },
    sorterOffset = 2.255989
  },
  chromium = {
    itemId = 705,
    itemProbability = 160,
    forexIndex = "CHR",
    displayName = "Krómérc",
    actionName = "króm rudat",
    ingotName = "Króm",
    ingotNamePrefix = "a",
    meltingPoint = 1920,
    meltingColor = {
      remapRgb(182, 182, 250)
    },
    sorterOffset = 2.900571,
    metallicOre = true
  },
  coal = {
    itemId = 706,
    itemProbability = 700,
    forexIndex = "COL",
    displayName = "Szén",
    actionName = "szenet",
    sorterOffset = 3.545153
  },
  copper = {
    itemId = 707,
    itemProbability = 300,
    forexIndex = "COP",
    displayName = "Rézérc",
    actionName = "rézrudat",
    ingotName = "Réz",
    ingotNamePrefix = "a",
    meltingPoint = 1100,
    meltingColor = {
      remapRgb(235, 134, 88)
    },
    sorterOffset = 4.189735,
    metallicOre = true
  },
  diamond = {
    itemId = 708,
    itemProbability = 10,
    forexIndex = "DIA",
    displayName = "Gyémánt",
    actionName = "gyémántot",
    sorterOffset = 4.834317,
    metallicOre = true
  },
  emerald = {
    itemId = 709,
    itemProbability = 20,
    forexIndex = "EMD",
    displayName = "Smaragd",
    actionName = "smaragdot",
    sorterOffset = 5.478899,
    metallicOre = true
  },
  gold = {
    itemId = 710,
    itemProbability = 45,
    forexIndex = "GOL",
    displayName = "Aranyérc",
    actionName = "aranyrudat",
    ingotName = "Arany",
    ingotNamePrefix = "az",
    meltingPoint = 1100,
    meltingColor = {
      remapRgb(245, 210, 128)
    },
    sorterOffset = 6.123481,
    metallicOre = true
  },
  iron = {
    itemId = 711,
    itemProbability = 600,
    forexIndex = "IRN",
    displayName = "Vasérc",
    actionName = "vasrudat",
    ingotName = "Vas",
    ingotNamePrefix = "a",
    meltingPoint = 1550,
    meltingColor = {
      remapRgb(130, 130, 150)
    },
    sorterOffset = 6.768063,
    metallicOre = true
  },
  nickel = {
    itemId = 712,
    itemProbability = 140,
    forexIndex = "NIK",
    displayName = "Nikkelérc",
    actionName = "nikkel rudat",
    ingotName = "Nikkel",
    ingotNamePrefix = "a",
    meltingPoint = 1460,
    meltingColor = {
      remapRgb(220, 220, 220)
    },
    sorterOffset = 7.412645,
    metallicOre = true
  },
  platinum = {
    itemId = 713,
    itemProbability = 65,
    forexIndex = "PLT",
    displayName = "Platinaérc",
    actionName = "platina rudat",
    ingotName = "Platina",
    ingotNamePrefix = "a",
    meltingPoint = 1800,
    meltingColor = {
      remapRgb(160, 170, 250)
    },
    sorterOffset = 8.057227,
    metallicOre = true
  },
  ruby = {
    itemId = 714,
    itemProbability = 12,
    forexIndex = "RUB",
    displayName = "Rubin",
    actionName = "rubint",
    sorterOffset = 8.701809,
    metallicOre = true
  },
  chest = {
    itemId = 722,
    itemProbability = 11,
    displayName = "Miner Chest",
    actionName = "Miner Chestet",
    metallicOre = true,
    instantItem = true,
    modelName = "v4_mining_chest2"
  },
  seerconium = {
    itemId = 723,
    itemProbability = 11,
    forexIndex = "SRC",
    displayName = "Seerconium",
    actionName = "Seerconiumot",
    metallicOre = true,
    instantItem = true,
    fixedBasePrice = 500000
  }
}
for _FORV_12_, _FORV_13_ in pairs(oreTypes) do
  if _FORV_13_.meltingPoint then
    _FORV_13_.furnaceSpeed = _FORV_13_.meltingPoint / 1000 * 60 / 2.5
  end
end
meltingTime = 75000 / 2.5
railIronCost = 2
railWoodCost = 5
mineCartLength = 1.58921
dieselLocoLength = 1.8262
function findRailConstructionCost(_ARG_0_)
  for _FORV_5_ = 1, #_ARG_0_ do
  end
  return 0 + 1
end
function canConstructRail(_ARG_0_, _ARG_1_, _ARG_2_, _ARG_3_)
  if _ARG_2_ < 0 then
    return false
  end
  if _ARG_0_[_ARG_2_] and _ARG_0_[_ARG_2_][_ARG_3_] then
    return false
  end
  if _ARG_1_[_ARG_2_] then
    if _ARG_1_[_ARG_2_][_ARG_3_] then
      return false
    end
    if _ARG_1_[_ARG_2_][_ARG_3_ - 1] then
      return true
    end
    if _ARG_1_[_ARG_2_][_ARG_3_ + 1] then
      return true
    end
  end
  if _ARG_1_[_ARG_2_ - 1] and _ARG_1_[_ARG_2_ - 1][_ARG_3_] then
    return true
  end
  if _ARG_1_[_ARG_2_ + 1] and _ARG_1_[_ARG_2_ + 1][_ARG_3_] then
    return true
  end
  if _ARG_0_[_ARG_2_] then
    if _ARG_0_[_ARG_2_][_ARG_3_ - 1] then
      return true
    end
    if _ARG_0_[_ARG_2_][_ARG_3_ + 1] then
      return true
    end
  end
  if _ARG_0_[_ARG_2_ - 1] and _ARG_0_[_ARG_2_ - 1][_ARG_3_] then
    return true
  end
  if _ARG_0_[_ARG_2_ + 1] and _ARG_0_[_ARG_2_ + 1][_ARG_3_] then
    return true
  end
  return false
end
function doConstructRail(_ARG_0_, _ARG_1_, _ARG_2_, _ARG_3_, _ARG_4_, _ARG_5_)
  if _ARG_5_ then
    if #getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_) == 2 then
      if findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId) % PI == findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId) % PI then
        return {
          {
            "merge",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId,
            _ARG_3_,
            _ARG_4_
          }
        }
      else
        return {
          {
            "openup",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId
          },
          {
            "openup",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId
          },
          {
            "switch",
            _ARG_3_,
            _ARG_4_
          }
        }
      end
    elseif #getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_) > 1 then
      for _FORV_11_ = 1, #getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_) do
        table.insert({}, {
          "openup",
          getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[_FORV_11_].trackId
        })
      end
      _FOR_.insert({}, {
        "switch",
        _ARG_3_,
        _ARG_4_
      })
      return {}
    else
      return {
        {
          "extend",
          getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId
        }
      }
    end
  elseif #getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_) + #getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_) == 1 then
    if #getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_) == 1 then
      if findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId) % PI == patan2(_ARG_4_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY, _ARG_3_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX) % PI then
        return {
          {
            "extend",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId
          }
        }
      else
        return {
          {
            "single",
            _ARG_3_,
            _ARG_4_,
            math.deg((patan2(_ARG_4_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY, _ARG_3_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX))),
            true
          },
          {
            "split",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY
          },
          {
            "switch",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY
          }
        }
      end
    else
      return {
        {
          "single",
          _ARG_3_,
          _ARG_4_,
          math.deg((patan2(_ARG_4_ - getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[1].switchY, _ARG_3_ - getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[1].switchX))),
          true
        },
        {
          "extend-switch",
          getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[1].switchId
        }
      }
    end
  elseif #getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_) + #getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_) == 2 then
    if #getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_) == 2 then
      if findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId) % PI == findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId) % PI then
        if findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId) % PI == patan2(_ARG_4_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY, _ARG_3_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX) then
          return {
            {
              "merge",
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId,
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId,
              _ARG_3_,
              _ARG_4_
            }
          }
        else
          return {
            {
              "single",
              _ARG_3_,
              _ARG_4_,
              math.deg((patan2(_ARG_4_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY, _ARG_3_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX))),
              false
            },
            {
              "split",
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId,
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX,
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY
            },
            {
              "split",
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId,
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackX,
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackY
            },
            {
              "switch",
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX,
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY
            },
            {
              "switch",
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackX,
              getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackY
            }
          }
        end
      elseif findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId) % PI == patan2(_ARG_4_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY, _ARG_3_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX) then
        return {
          {
            "extend",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId,
            true
          },
          {
            "split",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackX,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackY
          },
          {
            "switch",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackX,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackY
          }
        }
      elseif findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId) % PI == patan2(_ARG_4_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY, _ARG_3_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX) then
        return {
          {
            "extend",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[2].trackId,
            true
          },
          {
            "split",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY
          },
          {
            "switch",
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX,
            getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY
          }
        }
      end
    elseif #getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_) == 2 then
      return {
        {
          "single",
          _ARG_3_,
          _ARG_4_,
          math.deg(patan2(_ARG_4_ - getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[1].switchY, _ARG_3_ - getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[1].switchX)),
          false
        },
        {
          "extend-switch",
          getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[1].switchId
        },
        {
          "extend-switch",
          getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[2].switchId
        }
      }
    elseif findRailAngle(_ARG_0_, getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId) % PI == patan2(_ARG_4_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY, _ARG_3_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX) % PI then
      return {
        {
          "extend",
          getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId,
          true
        },
        {
          "extend-switch",
          getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[1].switchId
        }
      }
    else
      return {
        {
          "single",
          _ARG_3_,
          _ARG_4_,
          math.deg((patan2(_ARG_4_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY, _ARG_3_ - getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX))),
          false
        },
        {
          "split",
          getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackId,
          getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX,
          getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY
        },
        {
          "switch",
          getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackX,
          getNearTracks(_ARG_1_, _ARG_3_, _ARG_4_)[1].trackY
        },
        {
          "extend-switch",
          getNearSwitches(_ARG_2_, _ARG_3_, _ARG_4_)[1].switchId
        }
      }
    end
  end
end
function getNearTracks(_ARG_0_, _ARG_1_, _ARG_2_, _ARG_3_)
  for _FORV_9_ = 1, #{
    0,
    -1,
    0,
    1,
    -1,
    0,
    1,
    0
  }, 2 do
    if _ARG_0_[_ARG_1_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_9_]] and _ARG_0_[_ARG_1_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_9_]][_ARG_2_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_9_ + 1]] or _ARG_3_ and _ARG_3_[_ARG_1_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_9_]] and _ARG_3_[_ARG_1_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_9_]][_ARG_2_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_9_ + 1]] then
      table.insert({}, {
        trackId = _ARG_0_[_ARG_1_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_9_]] and _ARG_0_[_ARG_1_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_9_]][_ARG_2_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_9_ + 1]] or _ARG_3_ and _ARG_3_[_ARG_1_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_9_]] and _ARG_3_[_ARG_1_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_9_]][_ARG_2_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_9_ + 1]],
        trackX = _ARG_1_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_9_],
        trackY = _ARG_2_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_9_ + 1]
      })
    end
  end
  return {}
end
function getNearSwitches(_ARG_0_, _ARG_1_, _ARG_2_)
  for _FORV_8_ = 1, #{
    0,
    -1,
    0,
    1,
    -1,
    0,
    1,
    0
  }, 2 do
    if _ARG_0_[_ARG_1_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_8_]] and _ARG_0_[_ARG_1_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_8_]][_ARG_2_ + ({
      0,
      -1,
      0,
      1,
      -1,
      0,
      1,
      0
    })[_FORV_8_ + 1]] then
      table.insert({}, {
        switchId = _ARG_0_[_ARG_1_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_8_]] and _ARG_0_[_ARG_1_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_8_]][_ARG_2_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_8_ + 1]],
        switchX = _ARG_1_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_8_],
        switchY = _ARG_2_ + ({
          0,
          -1,
          0,
          1,
          -1,
          0,
          1,
          0
        })[_FORV_8_ + 1]
      })
    end
  end
  return {}
end
switchMatrix = {
  [2] = {
    [1] = {
      [1] = 2,
      [2] = 1
    }
  },
  [3] = {
    [1] = {
      [1] = 3,
      [2] = nil,
      [3] = 1
    },
    [2] = {
      [1] = nil,
      [2] = 3,
      [3] = 2
    },
    [3] = {
      [1] = 2,
      [2] = 1,
      [3] = nil
    }
  },
  [4] = {
    [1] = {
      [1] = 3,
      [2] = 4,
      [3] = 1,
      [4] = 2
    },
    [2] = {
      [1] = 4,
      [2] = 3,
      [3] = 2,
      [4] = 1
    },
    [3] = {
      [1] = 2,
      [2] = 1,
      [3] = 4,
      [4] = 3
    }
  }
}
locoPassengerSpots = {
  {
    -0.25,
    -1,
    1.35,
    0,
    "casino",
    "roulette_loop"
  },
  {
    -0.25,
    1,
    1.35,
    180,
    "casino",
    "roulette_loop"
  },
  {
    1,
    -0.75,
    1.35,
    0,
    "chainsaw",
    "idle_csaw"
  },
  {
    1,
    0.75,
    1.35,
    180,
    "chainsaw",
    "idle_csaw"
  }
}
oreCartOffsets = {
  {
    4,
    -0.409,
    0.095,
    -0.0219,
    -22.2652,
    0,
    0
  },
  {
    2,
    -0.0585,
    0.0118,
    -0.0219,
    0,
    0,
    58.7106
  },
  {
    1,
    0.3544,
    0.073,
    -0.0137,
    0,
    0,
    0
  },
  {
    5,
    -0.4016,
    -0.1819,
    0.2355,
    -17.6461,
    0,
    0
  },
  {
    3,
    0.3097,
    -0.1695,
    0.2292,
    -12.3947,
    -19.5927,
    33.2397
  },
  {
    1,
    0.1827,
    0.1348,
    0.2644,
    32.0566,
    -60.7096,
    7.051
  },
  {
    4,
    -0.2639,
    0.1789,
    0.3447,
    56.6072,
    -74.6252,
    -56.886
  }
}
machinePosX = minePosX - 13.7135
machinePosY = minePosY + 7.6567
machinePosZ = minePosZ + 1.5229
conveyorStartX = machinePosX + 0.8758
conveyorStartY = machinePosY - 6.9417
conveyorStartZ = machinePosZ - 0.8327
conveyorEndX = machinePosX + 0.8758
conveyorEndY = machinePosY - 0.9892
conveyorEndZ = machinePosZ + 1.4221
conveyorLength = getDistanceBetweenPoints3D(conveyorStartX, conveyorStartY, conveyorStartZ, conveyorEndX, conveyorEndY, conveyorEndZ)
conveyorDuration = 7000
sackOreProportion = 0.16666666666666666
detonationTime = 25000
fuelTankCapacity = 1000
jerryCanCapacity = 10
locoTankCapacity = 40
railIronStack = 50
railIronPrice = math.floor(37500 * globalPriceMultiplier + 0.5)
railIronOffsets = {
  {
    -17.7054,
    9.4165,
    -0.1814,
    -13,
    0,
    176
  },
  {
    -18.6844,
    9.4494,
    -0.1644,
    -13,
    0,
    180
  }
}
railWoodStack = 125
railWoodPrice = math.floor(12500 * globalPriceMultiplier + 0.5)
railWoodOffsets = {
  {
    -19.7923,
    9.1289,
    0.1735,
    0,
    0,
    0
  },
  {
    -20.9152,
    9.1289,
    0.1735,
    0,
    0,
    -2.5
  }
}
mineLampStack = 20
mineLampPrice = math.floor(20000 * globalPriceMultiplier + 0.5)
mineLampOffsets = {
  {
    -20.7103,
    4.6399,
    0.047,
    0,
    0,
    0
  },
  {
    -20.7103,
    6.2763,
    0.047,
    0,
    0,
    -85
  }
}
subRailCarPrice = math.floor(95000 * globalPriceMultiplier + 0.5)
dieselLocoPrice = 2500
trailerOffsets = {
  railIrons = {
    {
      "v4_mine_cargo_rail",
      -0.3941,
      0.3804,
      0.0131,
      0,
      0,
      0
    },
    {
      "v4_mine_cargo_rail",
      0.3961,
      0.3804,
      0.0131,
      0,
      0,
      0
    }
  },
  railWoods = {
    {
      "v4_mine_cargo_wood",
      -0.4237,
      0.3891,
      0.0131,
      0,
      0,
      180
    },
    {
      "v4_mine_cargo_wood",
      0.4274,
      0.3891,
      0.0131,
      0,
      0,
      0
    }
  },
  mineLamps = {
    {
      "v4_mine_cargo_lamp",
      0,
      -0.2947,
      0.0211,
      0,
      0,
      0
    },
    {
      "v4_mine_cargo_lamp",
      0,
      1.0424,
      0.0211,
      0,
      0,
      180
    }
  },
  dieselLoco = {
    {
      "v4_mine_cargo_urmamoto",
      0,
      0.1544,
      -0.2005,
      0,
      0,
      90
    }
  },
  subCartNum = {
    {
      "v4_mine_cargo_cart1",
      0,
      -0.2156,
      -0.2004,
      0,
      0,
      0
    },
    {
      "v4_mine_cargo_cart1",
      0,
      0.879,
      -0.2004,
      0,
      0,
      0
    }
  }
}
orderPoses = {
  {
    -2459.884,
    2487.887,
    13.7742,
    180,
    16,
    "James McGallaghon",
    -2460.6912,
    2482.1836,
    13.0003,
    3,
    3.42979
  },
  {
    -2463.3245,
    2489.7566,
    13.7742,
    0,
    16,
    "Billy Reic Idol",
    -2460.6912,
    2492.1836,
    13.0003,
    3,
    3.42979
  },
  {
    -2461.4534,
    2500.1694,
    13.7742,
    21,
    16,
    "Steven Applepine",
    -2460.6912,
    2502.1833,
    13.0003,
    3,
    3.42979
  }
}
function refreshOrderConstraints(_ARG_0_, _ARG_1_)
  for _FORV_5_ in pairs(_ARG_0_) do
    if not trailerOffsets[_FORV_5_] then
      _ARG_0_[_FORV_5_] = nil
    end
  end
  if _ARG_0_.railIrons or _ARG_0_.railWoods then
    _ARG_0_.mineLamps = nil
    _ARG_0_.dieselLoco = nil
    _ARG_0_.subCartNum = nil
  elseif _ARG_0_.mineLamps then
    _ARG_0_.railIrons = nil
    _ARG_0_.railWoods = nil
    _ARG_0_.dieselLoco = nil
    _ARG_0_.subCartNum = nil
  elseif _ARG_0_.dieselLoco then
    _ARG_0_.subCartNum = nil
  elseif _ARG_0_.subCartNum then
    _ARG_0_.dieselLoco = nil
  end
  if _ARG_0_.railIrons then
    _ARG_0_.railIrons = math.max(0, math.min(_ARG_0_.railIrons, 2 - math.ceil(_ARG_1_.railIrons / railIronStack)))
    _ARG_0_.railIrons = math.min(#trailerOffsets.railIrons - (_ARG_0_.railWoods or 0), _ARG_0_.railIrons)
    if _ARG_0_.railIrons <= 0 then
      _ARG_0_.railIrons = nil
    end
  end
  if _ARG_0_.railWoods then
    _ARG_0_.railWoods = math.max(0, math.min(_ARG_0_.railWoods, 2 - math.ceil(_ARG_1_.railWoods / railWoodStack)))
    _ARG_0_.railWoods = math.min(#trailerOffsets.railWoods - (_ARG_0_.railIrons or 0), _ARG_0_.railWoods)
    if _ARG_0_.railWoods <= 0 then
      _ARG_0_.railWoods = nil
    end
  end
  if _ARG_0_.mineLamps then
    _ARG_0_.mineLamps = math.max(0, math.min(_ARG_0_.mineLamps, 2 - math.ceil(_ARG_1_.mineLamps / mineLampStack)))
    _ARG_0_.mineLamps = math.min(#trailerOffsets.mineLamps, _ARG_0_.mineLamps)
    if _ARG_0_.mineLamps <= 0 then
      _ARG_0_.mineLamps = nil
    end
  end
  if _ARG_0_.dieselLoco then
    _ARG_0_.dieselLoco = math.max(0, math.min(_ARG_0_.dieselLoco or 0, _ARG_1_.dieselLoco and 0 or 1))
    _ARG_0_.dieselLoco = math.min(#trailerOffsets.dieselLoco, _ARG_0_.dieselLoco)
    if _ARG_0_.dieselLoco <= 0 then
      _ARG_0_.dieselLoco = nil
    end
  end
  if _ARG_0_.subCartNum then
    _ARG_0_.subCartNum = math.max(0, math.min(_ARG_0_.subCartNum or 0, (_ARG_1_.dieselLoco and 6 or 1) - _ARG_1_.subCartNum))
    _ARG_0_.subCartNum = math.min(#trailerOffsets.subCartNum, _ARG_0_.subCartNum)
    if _ARG_0_.subCartNum <= 0 then
      _ARG_0_.subCartNum = nil
    end
  end
end
function getOrderPrice(_ARG_0_)
  if _ARG_0_.dieselLoco then
  else
  end
  return dieselLocoPrice + railIronPrice * (_ARG_0_.railIrons or 0) + railWoodPrice * (_ARG_0_.railWoods or 0) + mineLampPrice * (_ARG_0_.mineLamps or 0) + dieselLocoPrice * (_ARG_0_.dieselLoco or 0) + subRailCarPrice * (_ARG_0_.subCartNum or 0), true
end
function iterateGrid(_ARG_0_, _ARG_1_, _ARG_2_, _ARG_3_, _ARG_4_, _ARG_5_)
  for _FORV_9_ = _ARG_1_, _ARG_3_ do
    if _ARG_0_[_FORV_9_] then
      for _FORV_13_ = _ARG_2_, _ARG_4_ do
        if _ARG_0_[_FORV_9_][_FORV_13_] then
          _ARG_5_(_ARG_0_[_FORV_9_][_FORV_13_], _FORV_9_, _FORV_13_)
        end
      end
    end
  end
end
function setPedHeadingTo(_ARG_0_, _ARG_1_, _ARG_2_)
  if isElement(_ARG_0_) then
    if isElement(_ARG_1_) then
      _ARG_1_, _ARG_2_ = getElementPosition(_ARG_1_)
    end
    return setElementRotation(_ARG_0_, 0, 0, math.deg(math.atan2(getElementPosition(_ARG_0_) - _ARG_2_, getElementPosition(_ARG_0_) - _ARG_1_)) + 90, "default", true)
  end
end
insideFarClipDistance = 36

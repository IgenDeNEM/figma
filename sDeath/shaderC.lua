
clockShaderSource = " struct PSInput { float4 Position : POSITION0; float2 TexCoord : TEXCOORD0; float3 WPos : TEXCOORD1; float4 SPos : TEXCOORD2; }; struct VSInput { float3 Position : POSITION0; float2 TexCoord : TEXCOORD0; }; float4x4 gWorld : WORLD; float4x4 gWorldViewProjection : WORLDVIEWPROJECTION; texture gTexture0 < string textureState=\"0,Texture\"; >; float3 MTACalcWorldPosition( float3 InPosition ) { return mul(float4(InPosition,1), gWorld).xyz; } PSInput VertexShaderFunction(VSInput VS) { PSInput PS = (PSInput)0; PS.Position = mul(float4(VS.Position, 1), gWorldViewProjection); PS.TexCoord = VS.TexCoord; PS.WPos = MTACalcWorldPosition(VS.Position).xyz; PS.SPos = PS.Position; return PS; } sampler Sampler0 = sampler_state { Texture = (gTexture0); }; texture cloud; sampler Sampler2 = sampler_state { Texture = (cloud); AddressU = Wrap; AddressV = Wrap; }; float3 portal = float3(1403.8828125, 436.25390625, 19.880048751831); bool clockSpawn = false; float3 clock = float3(1412.419921875, 424.6611328125, 19.857177734375); float3 lightningPos = float3(1403.8828125, 436.25390625, 19.880048751831); float lightning = 0; float4 PixelShaderFunction(PSInput PS) : COLOR0 { float4 color; float4 tex = tex2D(Sampler0, PS.TexCoord); float4 mask = tex2D(Sampler2, float2(PS.WPos.x*0.01, PS.WPos.y*0.01)); color = float4(tex.r, tex.g, tex.b, tex.a)*float4(0.125, 0.125, 0.125, 1)*lerp(float4(0.5, 0.6, 0.85, 1), float4(3, 0, 0, 1), mask.r); if(lightning > 0) { float prog = (1-distance(PS.WPos, lightningPos)/100)*15*lightning; if(prog > 0) { color.r *= 1+1*prog; color.g *= 1+0.25*prog; } } float prog = (1-distance(PS.WPos, portal)/5)*15; if(prog > 0) { color.r *= 1+1*prog; color.g *= 1+0.25*prog; } if(clockSpawn) { float prog2 = (1-distance(PS.WPos, clock)/2)*20; if(prog2 > 0) { color.r *= 1+0.15*prog2; color.g *= 1+0.5*prog2; color.b *= 1+1.0*prog2; } float prog3 = (1-distance(PS.WPos, float3(clock.x, clock.y, clock.z+1.5))/3)*10; if(prog3 > 0) { color.r *= 1+1*prog3; color.g *= 1-0.1*prog3; } } return color; } technique Technique1 { pass Pass1 { VertexShader = compile vs_2_0 VertexShaderFunction(); PixelShader = compile ps_2_0 PixelShaderFunction(); } } "
shaderSource = " struct PSInput { float4 Position : POSITION0; float2 TexCoord : TEXCOORD0; float3 WPos : TEXCOORD1; float4 SPos : TEXCOORD2; }; struct VSInput { float3 Position : POSITION0; float2 TexCoord : TEXCOORD0; }; float4x4 gWorld : WORLD; float4x4 gWorldViewProjection : WORLDVIEWPROJECTION; texture gTexture0 < string textureState=\"0,Texture\"; >; float3 MTACalcWorldPosition( float3 InPosition ) { return mul(float4(InPosition,1), gWorld).xyz; } PSInput VertexShaderFunction(VSInput VS) { PSInput PS = (PSInput)0; PS.Position = mul(float4(VS.Position, 1), gWorldViewProjection); PS.TexCoord = VS.TexCoord; PS.WPos = MTACalcWorldPosition(VS.Position).xyz; PS.SPos = PS.Position; return PS; } sampler Sampler0 = sampler_state { Texture = (gTexture0); }; texture texa; texture texb; texture cloud; texture portalRT; float shadTime; sampler Sampler1a = sampler_state { Texture = (texa); AddressU = Wrap; AddressV = Wrap; }; sampler Sampler1b = sampler_state { Texture = (texb); AddressU = Wrap; AddressV = Wrap; }; sampler Sampler2 = sampler_state { Texture = (cloud); AddressU = Wrap; AddressV = Wrap; }; sampler Sampler3 = sampler_state { Texture = (portalRT); AddressU = Wrap; AddressV = Wrap; }; texture secondRT < string renderTarget = \"yes\"; >; struct Pixel { float4 Color : COLOR0; float4 Extra : COLOR1; }; float3 portal = float3(1403.8828125, 436.25390625, 19.880048751831); float3 lightningPos = float3(1403.8828125, 436.25390625, 19.880048751831); float lightning = 0; bool clockSpawn = false; float3 clock = float3(1412.419921875, 424.6611328125, 19.857177734375); Pixel PixelShaderFunction(PSInput PS) { Pixel output; float4 tex = tex2D(Sampler0, PS.TexCoord); float4 tex2a = tex2D(Sampler1a, float2(PS.TexCoord.x+shadTime, PS.TexCoord.y+shadTime)); float4 tex2b = tex2D(Sampler1b, float2(PS.WPos.x*0.01, PS.WPos.y*0.01)); float4 mask = tex2D(Sampler2, float2(PS.WPos.x*0.01, PS.WPos.y*0.01)); float4 tex2 = lerp(tex2b, tex2a, tex2a.a); float3 outCol = lerp(tex.rgb, tex2.rgb, tex2.a); float2 sp = float2((PS.SPos.x/PS.SPos.w)/2+0.5, -(PS.SPos.y/PS.SPos.w)/2+0.5); float4 smask = tex2D(Sampler3, float2(sp.x, sp.y)); if(smask.r > 0) output.Color = tex*lerp(float4(1, 0.25, 0, 1), float4(1, 0.95, 0.8, 1), smask.r); else { output.Color = float4(outCol.r, outCol.g, outCol.b, tex.a)*float4(0.125, 0.125, 0.125, 1)*lerp(float4(0.5, 0.6, 0.85, 1), float4(3, 0, 0, 1), mask.r); if(lightning > 0) { float prog = (1-distance(PS.WPos, lightningPos)/100)*15*lightning; if(prog > 0) { output.Color.r *= 1+1*prog; output.Color.g *= 1+0.25*prog; } } if(clockSpawn) { float prog2 = (1-distance(PS.WPos, clock)/10)*12.5; if(prog2 > 0) { output.Color.r *= 1+0.75*prog2; output.Color.g *= 1+0.1*prog2; output.Color.b *= 1+1.0*prog2; } } } float prog = (1-distance(PS.WPos, portal)/5)*15; if(prog > 0) { output.Color.r *= 1+1*prog; output.Color.g *= 1+0.25*prog; } float d = 1-(PS.SPos.w-40)/(85-40); output.Extra = float4(d, d, d, 1); return output; } technique Technique1 { pass Pass1 { VertexShader = compile vs_2_0 VertexShaderFunction(); PixelShader = compile ps_2_0 PixelShaderFunction(); } } "
pedShaderSource = " struct PSInput { float4 Position : POSITION0; float2 TexCoord : TEXCOORD0; float2 WPos : TEXCOORD1; }; struct VSInput { float3 Position : POSITION0; float2 TexCoord : TEXCOORD0; }; float4x4 gWorld : WORLD; float4x4 gWorldViewProjection : WORLDVIEWPROJECTION; texture gTexture0 < string textureState=\"0,Texture\"; >; float3 MTACalcWorldPosition( float3 InPosition ) { return mul(float4(InPosition,1), gWorld).xyz; } texture cloud; sampler Sampler2 = sampler_state { Texture = (cloud); AddressU = Wrap; AddressV = Wrap; }; PSInput VertexShaderFunction(VSInput VS) { PSInput PS = (PSInput)0; PS.Position = mul(float4(VS.Position, 1), gWorldViewProjection); PS.TexCoord = VS.TexCoord; PS.WPos = MTACalcWorldPosition(VS.Position).xy; return PS; } sampler Sampler0 = sampler_state { Texture = (gTexture0); }; float3 portal = float3(1403.8828125, 436.25390625, 19.880048751831); float3 lightningPos = float3(1403.8828125, 436.25390625, 19.880048751831); float lightning = 0; bool clockSpawn = false; float3 clock = float3(1412.419921875, 424.6611328125, 19.857177734375); float4 PixelShaderFunction(PSInput PS) : COLOR0 { float4 tex = tex2D(Sampler0, PS.TexCoord); float4 mask = tex2D(Sampler2, float2(PS.WPos.x*0.01, PS.WPos.y*0.01)); float4 color = tex*float4(0.125, 0.125, 0.125, 1)*lerp(float4(0.5, 0.6, 0.85, 1), float4(3, 0, 0, 1), mask.r); if(lightning > 0) { float prog = (1-distance(PS.WPos, lightningPos)/100)*15*lightning; if(prog > 0) { color.r *= 1+1*prog; color.g *= 1+0.25*prog; } } float prog = (1-distance(PS.WPos, portal)/5)*15; if(prog > 0) { color.r *= 1+1*prog; color.g *= 1+0.25*prog; } if(clockSpawn) { float prog2 = (1-distance(PS.WPos, clock)/10)*12.5; if(prog2 > 0) { color.r *= 1+0.75*prog2; color.g *= 1+0.1*prog2; color.b *= 1+1.0*prog2; } } return color; } technique Technique1 { pass Pass1 { VertexShader = compile vs_2_0 VertexShaderFunction(); PixelShader = compile ps_2_0 PixelShaderFunction(); } } "
lightShaderSource = " struct PSInput { float4 Position : POSITION0; float2 TexCoord : TEXCOORD0; float4 Diffuse : COLOR0; float4 SPos : TEXCOORD1; }; struct VSInput { float3 Position : POSITION0; float2 TexCoord : TEXCOORD0; float4 Diffuse : COLOR0; }; float4x4 gWorldViewProjection : WORLDVIEWPROJECTION; texture gTexture0 < string textureState=\"0,Texture\"; >; texture portalRT; sampler Sampler3 = sampler_state { Texture = (portalRT); AddressU = Wrap; AddressV = Wrap; }; sampler Sampler0 = sampler_state { Texture = (gTexture0); }; float prog = 0; PSInput VertexShaderFunction(VSInput VS) { PSInput PS = (PSInput)0; PS.Position = mul(float4(VS.Position, 1), gWorldViewProjection); PS.TexCoord = VS.TexCoord; PS.Diffuse = VS.Diffuse; PS.SPos = PS.Position; return PS; } float4 PixelShaderFunction(PSInput PS) : COLOR0 { float4 tex = tex2D(Sampler0, PS.TexCoord); float2 sp = float2((PS.SPos.x/PS.SPos.w)/2+0.5, -(PS.SPos.y/PS.SPos.w)/2+0.5); float4 smask = tex2D(Sampler3, float2(sp.x, sp.y)); return float4(tex.r, tex.g, tex.b, tex.a)*PS.Diffuse*prog*(1-smask.r); } technique Technique1 { pass Pass1 { VertexShader = compile vs_2_0 VertexShaderFunction(); PixelShader = compile ps_2_0 PixelShaderFunction(); } } "
portalShaderSource = " texture secondRT < string renderTarget = \"yes\"; >; struct Pixel { float4 Color : COLOR0; float4 Extra : COLOR1; }; texture portalMask; sampler Sampler0 = sampler_state { Texture = (portalMask); }; texture noiseText; sampler Sampler1 = sampler_state { Texture = (noiseText); }; float shadTime = 0; Pixel PixelShaderFunction(float2 uv : TEXCOORD) { Pixel output; float side = tex2D(Sampler0, uv).r; float noiseText = 1-tex2D(Sampler1, uv+shadTime).r; float p = side*noiseText; output.Color = float4(1, 0.25, 0, 1)*p; output.Extra = float4(1-side, 1-side, 1-side, 1); return output; } technique Technique1 { pass Pass1 { AlphaBlendEnable = true; AlphaTestEnable = false; AlphaFunc = GreaterEqual; ShadeMode = Gouraud; ZEnable = false; FogEnable = false; SrcBlend = One; DestBlend = InvSrcAlpha; PixelShader = compile ps_2_0 PixelShaderFunction(); } } "
screenShaderSource = " texture sBaseTexture; sampler Samp = sampler_state { Texture = (sBaseTexture); AddressU = MIRROR; AddressV = MIRROR; }; texture worldRT; sampler Sampler2 = sampler_state { Texture = (worldRT); AddressU = Wrap; AddressV = Wrap; }; texture portalRT; sampler Sampler3 = sampler_state { Texture = (portalRT); AddressU = Wrap; AddressV = Wrap; }; float4 PixelShaderFunction(float2 uv : TEXCOORD) : COLOR { float4 output = tex2D(Samp, uv); float4 world = tex2D(Sampler2, uv); float4 portal = tex2D(Sampler3, uv); return lerp(output, float4(0.4, 0.9, 1, 1), portal.r*(1-world.r)); } technique movie { pass P0 { PixelShader = compile ps_2_0 PixelShaderFunction(); } } "
